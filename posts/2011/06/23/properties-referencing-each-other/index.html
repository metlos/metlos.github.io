<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Reinventing The Wheel</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <style>
      body {
        padding-top: 60px;
      }
    </style>
    <link href="http://lukas.krejci.pw/stylesheets/styles.css" rel="stylesheet" type="text/css">
    <link href="http://lukas.krejci.pw/stylesheets/font-awesome/font-awesome.css" rel="stylesheet" type="text/css">
    <link href="http://lukas.krejci.pw/stylesheets/coderay.css" rel="stylesheet" type="text/css">
    <script src="http://lukas.krejci.pw/javascripts/lightbox.min.js" type="text/javascript"></script>
    <!--[if lt IE 9]>
      <script src="//html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]-->
  </head>
  <body>
    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container-fluid">
        <div class="navbar-header">
          <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse" type="button">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>
        <a class="nav navbar-brand" href="http://lukas.krejci.pw" title="Reinventing The Wheel">
          <i class="fa fa-refresh"></i>
          <i class="fa fa-circle-o"></i>
        </a>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav navbar-right">
            <li>
              <a href="http://lukas.krejci.pw/posts" title="Blog">
                <i class="fa fa-pencil"></i>
              </a>
            </li>
            <li>
              <a href="http://lukas.krejci.pw/about" title="About">
                <i class="fa fa-info"></i>
              </a>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div class="container-fluid" role="main">
      <div class="post-navigation">
        <div class="previous">
          <div class="label">
            &laquo;
          </div>
          <div class="nav-link">
            <a href="/posts/2011/03/30/planning-configuration-and-templates-exportimport-in-rhq/">Planning configuration and templates export/import in RHQ</a>
          </div>
        </div>
        <div class="next">
          <div class="nav-link">
            <a href="/posts/2011/08/04/making-testng-listeners-apply-to-only-certain-classes/">Making TestNG @Listeners apply to only certain classes</a>
          </div>
          <div class="label">
            &raquo;
          </div>
        </div>
      </div>
      <h1 class="title">
        Properties referencing each other
      </h1>
      <div class="author">
        posted on
        <span class="date">
          23 Jun 2011
        </span>
      </div>
      <div class="tags">
        <a class="label label-info" href="http://lukas.krejci.pw/posts/tags/java/">java</a>
      </div>
      <div class="paragraph">
      <p>This must have been done before countless times but because I just
      couldn&#8217;t google anything useful (and to stay true to the name of this
      blog) I implemented it myself yet again.</p>
      </div>
      <div class="paragraph">
      <p>The problem is this. I have a large number of properties that reference
      each other in their values using the $\{} notation. E.g. the following
      property file:</p>
      </div>
      <div class="listingblock">
      <div class="content">
      <pre>message=Hello ${name}!&#x000A;name=Frank</pre>
      </div>
      </div>
      <div class="paragraph">
      <p>My actual use case for this is that I have a large number of
      configuration options that can be passed to a java program as system
      properties (i.e. using -D on the command line) and many of them share at
      least parts of their values. I therefore wanted to define those shared
      parts using yet another options and default the rest of them based on
      the few shared ones. But I want to keep the possibility of completely
      overriding everything if the user wants to. E.g.:</p>
      </div>
      <div class="paragraph">
      <p>These would be specified on the command line:</p>
      </div>
      <div class="listingblock">
      <div class="content">
      <pre>port=111&#x000A;host=localhost</pre>
      </div>
      </div>
      <div class="paragraph">
      <p>And the rest would be defaulted to the values based on the values above:</p>
      </div>
      <div class="listingblock">
      <div class="content">
      <pre>service1=${host}:${port}/service1&#x000A;service2=${host}:${port}/service2</pre>
      </div>
      </div>
      <div class="paragraph">
      <p>But that&#8217;s not all. Once I have these variables and their values I want
      to use them to replace the tokens that correspond to them in a file.
      E.g.:</p>
      </div>
      <div class="listingblock">
      <div class="content">
      <pre>This is a file I am then processing further and I want the service1 URL to be visible right here: ${service1}.</pre>
      </div>
      </div>
      <div class="paragraph">
      <p>Again that is a rather common requirement and nothing too surprising to
      do actually. But I still couldn&#8217;t find some nice and reusable class in
      some standard library that would efficiently do this for me.</p>
      </div>
      <div class="paragraph">
      <p>Then I stumbled upon the
      <a href="http://tutorials.jenkov.com/java-howto/replace-strings-in-streams-arrays-files.html">TokenReplacingReader</a>
      and thought to myself that that&#8217;s exactly the thing I need to solve
      <strong>both</strong> of my problems (after I fixed it slightly, see below).</p>
      </div>
      <div class="paragraph">
      <p>The TokenReplacingReader is ideal for my second usecase - read large
      files and replace tokens in them efficiently. But how do you say does it
      solve my first problem?. Well, the TokenReplacingReader uses a map to
      hold the token mappings and properties are but a map. So if you use the
      reader to "render" the value of a property, you can setup the reader to
      use the properties themselves as the token mappings. Can you see the
      beautiful recursion in there? ;)</p>
      </div>
      <div class="paragraph">
      <p>Ok, so here&#8217;s the code that I came up with:</p>
      </div>
      <div class="listingblock">
      <div class="content">
      <pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>&#x000A;  <td class="line-numbers"><pre>1&#x000A;2&#x000A;3&#x000A;4&#x000A;5&#x000A;6&#x000A;7&#x000A;8&#x000A;9&#x000A;<strong>10</strong>&#x000A;11&#x000A;12&#x000A;13&#x000A;14&#x000A;15&#x000A;16&#x000A;17&#x000A;18&#x000A;19&#x000A;<strong>20</strong>&#x000A;21&#x000A;22&#x000A;23&#x000A;24&#x000A;25&#x000A;26&#x000A;27&#x000A;28&#x000A;29&#x000A;<strong>30</strong>&#x000A;31&#x000A;32&#x000A;33&#x000A;34&#x000A;35&#x000A;36&#x000A;37&#x000A;38&#x000A;39&#x000A;<strong>40</strong>&#x000A;41&#x000A;42&#x000A;43&#x000A;44&#x000A;45&#x000A;46&#x000A;47&#x000A;48&#x000A;49&#x000A;<strong>50</strong>&#x000A;51&#x000A;52&#x000A;53&#x000A;54&#x000A;55&#x000A;56&#x000A;57&#x000A;58&#x000A;59&#x000A;<strong>60</strong>&#x000A;61&#x000A;62&#x000A;63&#x000A;64&#x000A;65&#x000A;66&#x000A;67&#x000A;68&#x000A;69&#x000A;<strong>70</strong>&#x000A;71&#x000A;72&#x000A;73&#x000A;74&#x000A;75&#x000A;76&#x000A;77&#x000A;78&#x000A;79&#x000A;<strong>80</strong>&#x000A;81&#x000A;82&#x000A;83&#x000A;84&#x000A;85&#x000A;86&#x000A;87&#x000A;88&#x000A;89&#x000A;<strong>90</strong>&#x000A;91&#x000A;92&#x000A;93&#x000A;94&#x000A;95&#x000A;96&#x000A;97&#x000A;98&#x000A;99&#x000A;<strong>100</strong>&#x000A;101&#x000A;102&#x000A;103&#x000A;104&#x000A;105&#x000A;106&#x000A;107&#x000A;108&#x000A;109&#x000A;<strong>110</strong>&#x000A;111&#x000A;112&#x000A;113&#x000A;114&#x000A;115&#x000A;116&#x000A;117&#x000A;118&#x000A;119&#x000A;<strong>120</strong>&#x000A;121&#x000A;122&#x000A;123&#x000A;124&#x000A;125&#x000A;126&#x000A;127&#x000A;128&#x000A;129&#x000A;<strong>130</strong>&#x000A;131&#x000A;132&#x000A;133&#x000A;134&#x000A;135&#x000A;136&#x000A;137&#x000A;138&#x000A;139&#x000A;<strong>140</strong>&#x000A;141&#x000A;142&#x000A;143&#x000A;144&#x000A;145&#x000A;146&#x000A;147&#x000A;148&#x000A;149&#x000A;<strong>150</strong>&#x000A;151&#x000A;152&#x000A;153&#x000A;154&#x000A;155&#x000A;156&#x000A;157&#x000A;158&#x000A;159&#x000A;<strong>160</strong>&#x000A;161&#x000A;162&#x000A;163&#x000A;164&#x000A;165&#x000A;166&#x000A;167&#x000A;168&#x000A;169&#x000A;<strong>170</strong>&#x000A;171&#x000A;172&#x000A;173&#x000A;174&#x000A;175&#x000A;176&#x000A;177&#x000A;178&#x000A;179&#x000A;<strong>180</strong>&#x000A;181&#x000A;182&#x000A;183&#x000A;184&#x000A;185&#x000A;186&#x000A;187&#x000A;188&#x000A;189&#x000A;<strong>190</strong>&#x000A;191&#x000A;192&#x000A;193&#x000A;194&#x000A;195&#x000A;196&#x000A;197&#x000A;198&#x000A;199&#x000A;<strong>200</strong>&#x000A;201&#x000A;202&#x000A;203&#x000A;204&#x000A;205&#x000A;206&#x000A;207&#x000A;208&#x000A;209&#x000A;<strong>210</strong>&#x000A;211&#x000A;212&#x000A;213&#x000A;214&#x000A;215&#x000A;216&#x000A;217&#x000A;218&#x000A;219&#x000A;<strong>220</strong>&#x000A;221&#x000A;222&#x000A;223&#x000A;224&#x000A;225&#x000A;226&#x000A;227&#x000A;228&#x000A;229&#x000A;<strong>230</strong>&#x000A;231&#x000A;232&#x000A;233&#x000A;234&#x000A;235&#x000A;236&#x000A;237&#x000A;238&#x000A;239&#x000A;<strong>240</strong>&#x000A;241&#x000A;242&#x000A;243&#x000A;244&#x000A;245&#x000A;246&#x000A;247&#x000A;248&#x000A;249&#x000A;<strong>250</strong>&#x000A;251&#x000A;252&#x000A;253&#x000A;254&#x000A;255&#x000A;256&#x000A;257&#x000A;258&#x000A;259&#x000A;<strong>260</strong>&#x000A;261&#x000A;262&#x000A;263&#x000A;264&#x000A;265&#x000A;266&#x000A;267&#x000A;268&#x000A;269&#x000A;<strong>270</strong>&#x000A;271&#x000A;272&#x000A;273&#x000A;274&#x000A;275&#x000A;276&#x000A;277&#x000A;278</pre></td>
        <td class="code"><pre><span class="comment">/**&#x000A; * This map is basically an extension of the {@link Properties} class that can resolve the references&#x000A; * to values of other keys inside the values.&#x000A; * &lt;p&gt;&#x000A; * I.e., if the map is initialized with the following mappings:&#x000A; * &lt;p&gt;&#x000A; * &lt;code&gt;&#x000A; * name =&gt; world &lt;br /&gt;&#x000A; * hello =&gt; Hello ${name}!&#x000A; * &lt;/code&gt;&#x000A; * &lt;p&gt;&#x000A; * then the call to:&#x000A; * &lt;p&gt;&#x000A; * &lt;code&gt;&#x000A; * get(&quot;hello&quot;)&#x000A; * &lt;/code&gt;&#x000A; * &lt;p&gt;&#x000A; * will return:&#x000A; * &lt;code&gt;&#x000A; * &quot;Hello world!&quot;&#x000A; * &lt;/code&gt;&#x000A; * &lt;p&gt;&#x000A; * To access and modify the underlying unprocessed values, one can use the &quot;raw&quot; counterparts of the standard&#x000A; * map methods (e.g. instead of {@link #get(Object)}, use {@link #getRaw(Object)}, etc.).&#x000A; *&#x000A; * @author Lukas Krejci&#x000A; */</span>&#x000A;<span class="directive">public</span> <span class="type">class</span> <span class="class">TokenReplacingProperties</span> <span class="directive">extends</span> <span class="predefined-type">HashMap</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; {&#x000A;    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">long</span> serialVersionUID = <span class="integer">1L</span>;&#x000A;&#x000A;    <span class="directive">private</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; wrapped;&#x000A;    <span class="directive">private</span> Deque&lt;<span class="predefined-type">String</span>&gt; currentResolutionStack = <span class="keyword">new</span> ArrayDeque&lt;<span class="predefined-type">String</span>&gt;();&#x000A;    <span class="directive">private</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">Object</span>, <span class="predefined-type">String</span>&gt; resolved = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;<span class="predefined-type">Object</span>, <span class="predefined-type">String</span>&gt;();&#x000A;&#x000A;    <span class="directive">private</span> <span class="type">class</span> <span class="class">Entry</span> <span class="directive">implements</span> <span class="predefined-type">Map</span>.Entry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; {&#x000A;        <span class="directive">private</span> <span class="predefined-type">Map</span>.Entry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; wrapped;&#x000A;        <span class="directive">private</span> <span class="type">boolean</span> process;&#x000A;&#x000A;        <span class="directive">public</span> Entry(<span class="predefined-type">Map</span>.Entry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; wrapped, <span class="type">boolean</span> process) {&#x000A;            <span class="local-variable">this</span>.wrapped = wrapped;&#x000A;            <span class="local-variable">this</span>.process = process;&#x000A;        }&#x000A;&#x000A;        <span class="annotation">@Override</span>&#x000A;        <span class="directive">public</span> <span class="type">boolean</span> equals(<span class="predefined-type">Object</span> obj) {&#x000A;            <span class="keyword">if</span> (obj == <span class="local-variable">this</span>) {&#x000A;                <span class="keyword">return</span> <span class="predefined-constant">true</span>;&#x000A;            }&#x000A;&#x000A;            <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Entry)) {&#x000A;                <span class="keyword">return</span> <span class="predefined-constant">false</span>;&#x000A;            }&#x000A;&#x000A;            Entry other = (Entry) obj;&#x000A;&#x000A;            <span class="predefined-type">String</span> key = wrapped.getKey();&#x000A;            <span class="predefined-type">String</span> otherKey = other.getKey();&#x000A;            <span class="predefined-type">String</span> value = getValue();&#x000A;            <span class="predefined-type">String</span> otherValue = other.getValue();&#x000A;&#x000A;            <span class="keyword">return</span> (key == <span class="predefined-constant">null</span> ? otherKey == <span class="predefined-constant">null</span> : key.equals(otherKey)) &amp;&amp;&#x000A;                   (value == <span class="predefined-constant">null</span> ? otherValue == <span class="predefined-constant">null</span> : value.equals(otherValue));&#x000A;        }&#x000A;&#x000A;        <span class="directive">public</span> <span class="predefined-type">String</span> getKey() {&#x000A;            <span class="keyword">return</span> wrapped.getKey();&#x000A;        }&#x000A;&#x000A;        <span class="directive">public</span> <span class="predefined-type">String</span> getValue() {&#x000A;            <span class="keyword">if</span> (process) {&#x000A;                <span class="keyword">return</span> get(wrapped.getKey());&#x000A;            } <span class="keyword">else</span> {&#x000A;                <span class="keyword">return</span> wrapped.getValue();&#x000A;            }&#x000A;        }&#x000A;&#x000A;        <span class="annotation">@Override</span>&#x000A;        <span class="directive">public</span> <span class="type">int</span> hashCode() {&#x000A;            <span class="predefined-type">String</span> key = wrapped.getKey();&#x000A;            <span class="predefined-type">String</span> value = getValue();&#x000A;            <span class="keyword">return</span> (key == <span class="predefined-constant">null</span> ? <span class="integer">0</span> : key.hashCode()) ^&#x000A;            (value == <span class="predefined-constant">null</span> ? <span class="integer">0</span> : value.hashCode());&#x000A;        }&#x000A;&#x000A;        <span class="directive">public</span> <span class="predefined-type">String</span> setValue(<span class="predefined-type">String</span> value) {&#x000A;            resolved.remove(wrapped.getKey());&#x000A;            <span class="keyword">return</span> wrapped.setValue(value);&#x000A;        }&#x000A;&#x000A;        <span class="annotation">@Override</span>&#x000A;        <span class="directive">public</span> <span class="predefined-type">String</span> toString() {&#x000A;            <span class="keyword">return</span> wrapped.toString();&#x000A;        }&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> TokenReplacingProperties(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; wrapped) {&#x000A;        <span class="local-variable">this</span>.wrapped = wrapped;&#x000A;    }&#x000A;&#x000A;    <span class="annotation">@SuppressWarnings</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">unchecked</span><span class="delimiter">&quot;</span></span>)&#x000A;    <span class="directive">public</span> TokenReplacingProperties(<span class="predefined-type">Properties</span> properties) {&#x000A;        <span class="comment">//well, this is ugly, but per documentation of Properties,</span>&#x000A;        <span class="comment">//both keys and values are always strings, so we can afford</span>&#x000A;        <span class="comment">//this little hack.</span>&#x000A;        <span class="annotation">@SuppressWarnings</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">rawtypes</span><span class="delimiter">&quot;</span></span>)&#x000A;        <span class="predefined-type">Map</span> map = properties;&#x000A;        <span class="local-variable">this</span>.wrapped = (<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;) map;&#x000A;    }&#x000A;&#x000A;    <span class="annotation">@Override</span>&#x000A;    <span class="directive">public</span> <span class="predefined-type">String</span> get(<span class="predefined-type">Object</span> key) {&#x000A;        <span class="keyword">if</span> (resolved.containsKey(key)) {&#x000A;            <span class="keyword">return</span> resolved.get(key);&#x000A;        }&#x000A;&#x000A;        <span class="keyword">if</span> (currentResolutionStack.contains(key)) {&#x000A;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Property '</span><span class="delimiter">&quot;</span></span> + key + <span class="string"><span class="delimiter">&quot;</span><span class="content">' indirectly references itself in its value.</span><span class="delimiter">&quot;</span></span>);&#x000A;        }&#x000A;&#x000A;        <span class="predefined-type">String</span> rawValue = getRaw(key);&#x000A;&#x000A;        <span class="keyword">if</span> (rawValue == <span class="predefined-constant">null</span>) {&#x000A;            <span class="keyword">return</span> <span class="predefined-constant">null</span>;&#x000A;        }&#x000A;&#x000A;        currentResolutionStack.push(key.toString());&#x000A;&#x000A;        <span class="predefined-type">String</span> ret = readAll(<span class="keyword">new</span> TokenReplacingReader(<span class="keyword">new</span> <span class="predefined-type">StringReader</span>(rawValue.toString()), <span class="local-variable">this</span>));&#x000A;&#x000A;        currentResolutionStack.pop();&#x000A;&#x000A;        resolved.put(key, ret);&#x000A;&#x000A;        <span class="keyword">return</span> ret;&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> <span class="predefined-type">String</span> getRaw(<span class="predefined-type">Object</span> key) {&#x000A;        <span class="keyword">return</span> wrapped.get(key);&#x000A;    }&#x000A;&#x000A;    <span class="annotation">@Override</span>&#x000A;    <span class="directive">public</span> <span class="predefined-type">String</span> put(<span class="predefined-type">String</span> key, <span class="predefined-type">String</span> value) {&#x000A;        resolved.remove(key);&#x000A;        <span class="keyword">return</span> wrapped.put(key, value);&#x000A;    }&#x000A;&#x000A;    <span class="annotation">@Override</span>&#x000A;    <span class="directive">public</span> <span class="type">void</span> putAll(<span class="predefined-type">Map</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">String</span>, ? <span class="directive">extends</span> <span class="predefined-type">String</span>&gt; m) {&#x000A;        <span class="keyword">for</span>(<span class="predefined-type">String</span> key : m.keySet()) {&#x000A;            resolved.remove(key);&#x000A;        }&#x000A;        wrapped.putAll(m);&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> <span class="type">void</span> putAll(<span class="predefined-type">Properties</span> properties) {&#x000A;        <span class="keyword">for</span>(<span class="predefined-type">String</span> propName : properties.stringPropertyNames()) {&#x000A;            put(propName, properties.getProperty(propName));&#x000A;        }&#x000A;    }&#x000A;&#x000A;    <span class="annotation">@Override</span>&#x000A;    <span class="directive">public</span> <span class="type">void</span> clear() {&#x000A;        wrapped.clear();&#x000A;        resolved.clear();&#x000A;    }&#x000A;&#x000A;    <span class="annotation">@Override</span>&#x000A;    <span class="directive">public</span> <span class="type">boolean</span> containsKey(<span class="predefined-type">Object</span> key) {&#x000A;        <span class="keyword">return</span> wrapped.containsKey(key);&#x000A;    }&#x000A;&#x000A;    <span class="annotation">@Override</span>&#x000A;    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; keySet() {&#x000A;        <span class="keyword">return</span> wrapped.keySet();&#x000A;    }&#x000A;&#x000A;    <span class="annotation">@Override</span>&#x000A;    <span class="directive">public</span> <span class="type">boolean</span> containsValue(<span class="predefined-type">Object</span> value) {&#x000A;        <span class="keyword">for</span>(<span class="predefined-type">String</span> key : keySet()) {&#x000A;            <span class="predefined-type">String</span> thisVal = get(key);&#x000A;            <span class="keyword">if</span> (thisVal == <span class="predefined-constant">null</span>) {&#x000A;                <span class="keyword">if</span> (value == <span class="predefined-constant">null</span>) {&#x000A;                    <span class="keyword">return</span> <span class="predefined-constant">true</span>;&#x000A;                }&#x000A;            } <span class="keyword">else</span> {&#x000A;                <span class="keyword">if</span> (thisVal.equals(value)) {&#x000A;                    <span class="keyword">return</span> <span class="predefined-constant">true</span>;&#x000A;                }&#x000A;            }&#x000A;        }&#x000A;&#x000A;        <span class="keyword">return</span> <span class="predefined-constant">false</span>;&#x000A;    }&#x000A;&#x000A;    <span class="comment">/**&#x000A;     * Checks whether this map contains the unprocessed value.&#x000A;     *&#x000A;     * @param value&#x000A;     * @return&#x000A;     */</span>&#x000A;    <span class="directive">public</span> <span class="type">boolean</span> containsRawValue(<span class="predefined-type">Object</span> value) {&#x000A;        <span class="keyword">return</span> wrapped.containsValue(value);&#x000A;    }&#x000A;&#x000A;    <span class="comment">/**&#x000A;     * The returned set &lt;b&gt;IS NOT&lt;/b&gt; backed by this map&#x000A;     * (unlike in the default map implementations).&#x000A;     * &lt;p&gt;&#x000A;     * The {@link java.util.Map.Entry#setValue(Object)} method&#x000A;     * does modify this map though.&#x000A;     */</span>&#x000A;    <span class="annotation">@Override</span>&#x000A;    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Map</span>.Entry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;&gt; entrySet() {&#x000A;        <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Map</span>.Entry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;&gt; ret = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;<span class="predefined-type">Map</span>.Entry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;&gt;();&#x000A;        <span class="keyword">for</span>(<span class="predefined-type">Map</span>.Entry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; entry : wrapped.entrySet()) {&#x000A;            ret.add(<span class="keyword">new</span> Entry(entry, <span class="predefined-constant">true</span>));&#x000A;        }&#x000A;&#x000A;        <span class="keyword">return</span> ret;&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Map</span>.Entry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;&gt; getRawEntrySet() {&#x000A;        <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Map</span>.Entry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;&gt; ret = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;<span class="predefined-type">Map</span>.Entry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;&gt;();&#x000A;        <span class="keyword">for</span>(<span class="predefined-type">Map</span>.Entry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; entry : wrapped.entrySet()) {&#x000A;            ret.add(<span class="keyword">new</span> Entry(entry, <span class="predefined-constant">false</span>));&#x000A;        }&#x000A;&#x000A;        <span class="keyword">return</span> ret;&#x000A;    }&#x000A;&#x000A;    <span class="annotation">@Override</span>&#x000A;    <span class="directive">public</span> <span class="predefined-type">String</span> remove(<span class="predefined-type">Object</span> key) {&#x000A;        resolved.remove(key);&#x000A;        <span class="keyword">return</span> wrapped.remove(key).toString();&#x000A;    }&#x000A;&#x000A;    <span class="annotation">@Override</span>&#x000A;    <span class="directive">public</span> <span class="type">int</span> size() {&#x000A;        <span class="keyword">return</span> wrapped.size();&#x000A;    }&#x000A;&#x000A;    <span class="comment">/**&#x000A;     * Unlike in the default implementation the collection returned&#x000A;     * from this method &lt;b&gt;IS NOT&lt;/b&gt; backed by this map.&#x000A;     */</span>&#x000A;    <span class="annotation">@Override</span>&#x000A;    <span class="directive">public</span> <span class="predefined-type">Collection</span>&lt;<span class="predefined-type">String</span>&gt; values() {&#x000A;        <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; ret = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">String</span>&gt;();&#x000A;        <span class="keyword">for</span>(<span class="predefined-type">String</span> key : keySet()) {&#x000A;            ret.add(get(key));&#x000A;        }&#x000A;&#x000A;        <span class="keyword">return</span> ret;&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> <span class="predefined-type">Collection</span>&lt;<span class="predefined-type">String</span>&gt; getRawValues() {&#x000A;        <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; ret = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">String</span>&gt;();&#x000A;        <span class="keyword">for</span>(<span class="predefined-type">String</span> key : keySet()) {&#x000A;            ret.add(wrapped.get(key));&#x000A;        }&#x000A;&#x000A;        <span class="keyword">return</span> ret;&#x000A;    }&#x000A;&#x000A;    <span class="directive">private</span> <span class="predefined-type">String</span> readAll(<span class="predefined-type">Reader</span> rdr) {&#x000A;        <span class="type">int</span> in = -<span class="integer">1</span>;&#x000A;        <span class="predefined-type">StringBuilder</span> bld = <span class="keyword">new</span> <span class="predefined-type">StringBuilder</span>();&#x000A;        <span class="keyword">try</span> {&#x000A;            <span class="keyword">while</span> ((in = rdr.read()) != -<span class="integer">1</span>) {&#x000A;                bld.append((<span class="type">char</span>) in);&#x000A;            }&#x000A;        } <span class="keyword">catch</span> (<span class="exception">IOException</span> e) {&#x000A;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Exception while reading a string.</span><span class="delimiter">&quot;</span></span>, e);&#x000A;        }&#x000A;&#x000A;        <span class="keyword">return</span> bld.toString();&#x000A;    }&#x000A;}</pre></td>
      </tr></table></code></pre>
      </div>
      </div>
      <div class="paragraph">
      <p>The TokenReplacingReader as implemented in the original blog post of
      Jakob Jenkov had a bug in it, so I had to fix it slightly:</p>
      </div>
      <div class="listingblock">
      <div class="content">
      <pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>&#x000A;  <td class="line-numbers"><pre>1&#x000A;2&#x000A;3&#x000A;4&#x000A;5&#x000A;6&#x000A;7&#x000A;8&#x000A;9&#x000A;<strong>10</strong>&#x000A;11&#x000A;12&#x000A;13&#x000A;14&#x000A;15&#x000A;16&#x000A;17&#x000A;18&#x000A;19&#x000A;<strong>20</strong>&#x000A;21&#x000A;22&#x000A;23&#x000A;24&#x000A;25&#x000A;26&#x000A;27&#x000A;28&#x000A;29&#x000A;<strong>30</strong>&#x000A;31&#x000A;32&#x000A;33&#x000A;34&#x000A;35&#x000A;36&#x000A;37&#x000A;38&#x000A;39&#x000A;<strong>40</strong>&#x000A;41&#x000A;42&#x000A;43&#x000A;44&#x000A;45&#x000A;46&#x000A;47&#x000A;48&#x000A;49&#x000A;<strong>50</strong>&#x000A;51&#x000A;52&#x000A;53&#x000A;54&#x000A;55&#x000A;56&#x000A;57&#x000A;58&#x000A;59&#x000A;<strong>60</strong>&#x000A;61&#x000A;62&#x000A;63&#x000A;64&#x000A;65&#x000A;66&#x000A;67&#x000A;68&#x000A;69&#x000A;<strong>70</strong>&#x000A;71&#x000A;72&#x000A;73&#x000A;74&#x000A;75&#x000A;76&#x000A;77&#x000A;78&#x000A;79&#x000A;<strong>80</strong>&#x000A;81&#x000A;82&#x000A;83&#x000A;84&#x000A;85&#x000A;86&#x000A;87&#x000A;88&#x000A;89&#x000A;<strong>90</strong>&#x000A;91&#x000A;92&#x000A;93&#x000A;94&#x000A;95&#x000A;96&#x000A;97&#x000A;98&#x000A;99&#x000A;<strong>100</strong>&#x000A;101&#x000A;102&#x000A;103&#x000A;104&#x000A;105&#x000A;106&#x000A;107&#x000A;108&#x000A;109&#x000A;<strong>110</strong>&#x000A;111&#x000A;112&#x000A;113&#x000A;114&#x000A;115&#x000A;116&#x000A;117&#x000A;118&#x000A;119</pre></td>
        <td class="code"><pre><span class="comment">/**&#x000A; * Copied from http://tutorials.jenkov.com/java-howto/replace-strings-in-streams-arrays-files.html&#x000A; * with fixes to {@link #read(char[], int, int)} and added support for escaping.&#x000A; *&#x000A; * @author Lukas Krejci&#x000A; */</span>&#x000A;<span class="directive">public</span> <span class="type">class</span> <span class="class">TokenReplacingReader</span> <span class="directive">extends</span> <span class="predefined-type">Reader</span> {&#x000A;&#x000A;    <span class="directive">private</span> <span class="predefined-type">PushbackReader</span> pushbackReader = <span class="predefined-constant">null</span>;&#x000A;    <span class="directive">private</span> <span class="predefined-type">Map</span>&gt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; tokens = <span class="predefined-constant">null</span>;&#x000A;    <span class="directive">private</span> <span class="predefined-type">StringBuilder</span> tokenNameBuffer = <span class="keyword">new</span> <span class="predefined-type">StringBuilder</span>();&#x000A;    <span class="directive">private</span> <span class="predefined-type">String</span> tokenValue = <span class="predefined-constant">null</span>;&#x000A;    <span class="directive">private</span> <span class="type">int</span> tokenValueIndex = <span class="integer">0</span>;&#x000A;    <span class="directive">private</span> <span class="type">boolean</span> escaping = <span class="predefined-constant">false</span>;&#x000A;&#x000A;    <span class="directive">public</span> TokenReplacingReader(<span class="predefined-type">Reader</span> source, <span class="predefined-type">Map</span>&gt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; tokens) {&#x000A;        <span class="local-variable">this</span>.pushbackReader = <span class="keyword">new</span> <span class="predefined-type">PushbackReader</span>(source, <span class="integer">2</span>);&#x000A;        <span class="local-variable">this</span>.tokens = tokens;&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> <span class="type">int</span> read(<span class="predefined-type">CharBuffer</span> target) <span class="directive">throws</span> <span class="exception">IOException</span> {&#x000A;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Operation Not Supported</span><span class="delimiter">&quot;</span></span>);&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> <span class="type">int</span> read() <span class="directive">throws</span> <span class="exception">IOException</span> {&#x000A;        <span class="keyword">if</span> (<span class="local-variable">this</span>.tokenValue != <span class="predefined-constant">null</span>) {&#x000A;            <span class="keyword">if</span> (<span class="local-variable">this</span>.tokenValueIndex &gt; <span class="local-variable">this</span>.tokenValue.length()) {&#x000A;                <span class="keyword">return</span> <span class="local-variable">this</span>.tokenValue.charAt(<span class="local-variable">this</span>.tokenValueIndex++);&#x000A;            }&#x000A;            <span class="keyword">if</span> (<span class="local-variable">this</span>.tokenValueIndex == <span class="local-variable">this</span>.tokenValue.length()) {&#x000A;                <span class="local-variable">this</span>.tokenValue = <span class="predefined-constant">null</span>;&#x000A;                <span class="local-variable">this</span>.tokenValueIndex = <span class="integer">0</span>;&#x000A;            }&#x000A;        }&#x000A;&#x000A;        <span class="type">int</span> data = <span class="local-variable">this</span>.pushbackReader.read();&#x000A;&#x000A;        <span class="keyword">if</span> (escaping) {&#x000A;            escaping = <span class="predefined-constant">false</span>;&#x000A;            <span class="keyword">return</span> data;&#x000A;        }&#x000A;&#x000A;        <span class="keyword">if</span> (data == <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="delimiter">'</span></span>) {&#x000A;            escaping = <span class="predefined-constant">true</span>;&#x000A;            <span class="keyword">return</span> data;&#x000A;        }&#x000A;&#x000A;        <span class="keyword">if</span> (data != <span class="string"><span class="delimiter">'</span><span class="content">$</span><span class="delimiter">'</span></span>)&#x000A;            <span class="keyword">return</span> data;&#x000A;&#x000A;        data = <span class="local-variable">this</span>.pushbackReader.read();&#x000A;        <span class="keyword">if</span> (data != <span class="string"><span class="delimiter">'</span><span class="content">{</span><span class="delimiter">'</span></span>) {&#x000A;            <span class="local-variable">this</span>.pushbackReader.unread(data);&#x000A;            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="content">$</span><span class="delimiter">'</span></span>;&#x000A;        }&#x000A;        <span class="local-variable">this</span>.tokenNameBuffer.delete(<span class="integer">0</span>, <span class="local-variable">this</span>.tokenNameBuffer.length());&#x000A;&#x000A;        data = <span class="local-variable">this</span>.pushbackReader.read();&#x000A;        <span class="keyword">while</span> (data != <span class="string"><span class="delimiter">'</span><span class="content">}</span><span class="delimiter">'</span></span>) {&#x000A;            <span class="local-variable">this</span>.tokenNameBuffer.append((<span class="type">char</span>) data);&#x000A;            data = <span class="local-variable">this</span>.pushbackReader.read();&#x000A;        }&#x000A;&#x000A;        <span class="local-variable">this</span>.tokenValue = tokens.get(<span class="local-variable">this</span>.tokenNameBuffer.toString());&#x000A;&#x000A;        <span class="keyword">if</span> (<span class="local-variable">this</span>.tokenValue == <span class="predefined-constant">null</span>) {&#x000A;            <span class="local-variable">this</span>.tokenValue = <span class="string"><span class="delimiter">&quot;</span><span class="content">${</span><span class="delimiter">&quot;</span></span> + <span class="local-variable">this</span>.tokenNameBuffer.toString() + <span class="string"><span class="delimiter">&quot;</span><span class="content">}</span><span class="delimiter">&quot;</span></span>;&#x000A;        }&#x000A;&#x000A;        <span class="keyword">if</span> (!<span class="local-variable">this</span>.tokenValue.isEmpty()) {&#x000A;            <span class="keyword">return</span> <span class="local-variable">this</span>.tokenValue.charAt(<span class="local-variable">this</span>.tokenValueIndex++);&#x000A;        } <span class="keyword">else</span> {&#x000A;            <span class="keyword">return</span> read();&#x000A;        }&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> <span class="type">int</span> read(<span class="type">char</span> cbuf<span class="type">[]</span>) <span class="directive">throws</span> <span class="exception">IOException</span> {&#x000A;        <span class="keyword">return</span> read(cbuf, <span class="integer">0</span>, cbuf.length);&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> <span class="type">int</span> read(<span class="type">char</span> cbuf<span class="type">[]</span>, <span class="type">int</span> off, <span class="type">int</span> len) <span class="directive">throws</span> <span class="exception">IOException</span> {&#x000A;        <span class="type">int</span> i = <span class="integer">0</span>;&#x000A;        <span class="keyword">for</span> (; i &gt; len; i++) {&#x000A;            <span class="type">int</span> nextChar = read();&#x000A;            <span class="keyword">if</span> (nextChar == -<span class="integer">1</span>) {&#x000A;                <span class="keyword">if</span> (i == <span class="integer">0</span>) {&#x000A;                    i = -<span class="integer">1</span>;&#x000A;                }&#x000A;                <span class="keyword">break</span>;&#x000A;            }&#x000A;            cbuf[off + i] = (<span class="type">char</span>) nextChar;&#x000A;        }&#x000A;        <span class="keyword">return</span> i;&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> <span class="type">void</span> close() <span class="directive">throws</span> <span class="exception">IOException</span> {&#x000A;        <span class="local-variable">this</span>.pushbackReader.close();&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> <span class="type">long</span> skip(<span class="type">long</span> n) <span class="directive">throws</span> <span class="exception">IOException</span> {&#x000A;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">UnsupportedOperationException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">skip() not supported on TokenReplacingReader.</span><span class="delimiter">&quot;</span></span>);&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> <span class="type">boolean</span> ready() <span class="directive">throws</span> <span class="exception">IOException</span> {&#x000A;        <span class="keyword">return</span> <span class="local-variable">this</span>.pushbackReader.ready();&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> <span class="type">boolean</span> markSupported() {&#x000A;        <span class="keyword">return</span> <span class="predefined-constant">false</span>;&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> <span class="type">void</span> mark(<span class="type">int</span> readAheadLimit) <span class="directive">throws</span> <span class="exception">IOException</span> {&#x000A;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IOException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">mark() not supported on TokenReplacingReader.</span><span class="delimiter">&quot;</span></span>);&#x000A;    }&#x000A;&#x000A;    <span class="directive">public</span> <span class="type">void</span> reset() <span class="directive">throws</span> <span class="exception">IOException</span> {&#x000A;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IOException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">reset() not supported on TokenReplacingReader.</span><span class="delimiter">&quot;</span></span>);&#x000A;    }&#x000A;}</pre></td>
      </tr></table></code></pre>
      </div>
      </div>
      
                  <div id="disqus_thread"></div>
                  <script type="text/javascript">
                  var disqus_shortname = 'lukaskrejcipw';
                  var disqus_url = "http://lukas.krejci.pw/posts/2011/06/23/properties-referencing-each-other/";
                  var disqus_developer = null;
                  var disqus_identifier = "d6d2d90e46e13bf9b44db6d7d4c740343d9abcd0";
                  (function() {
                    var dsq = document.createElement("script"); dsq.type = "text/javascript"; dsq.async = true;
                    dsq.src = "http://lukaskrejcipw.disqus.com/embed.js";
                    (document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0]).appendChild(dsq);
                  })();
                  </script>
                  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=lukaskrejcipw">comments powered by Disqus.</a></noscript>
      <hr>
      <footer>
        <div class="links">
          <a href="http://lukas.krejci.pw/blog.atom">
            <i class="fa fa-rss"></i>
          </a>
          <a href="https://plus.google.com/+lukaskrejci/">
            <i class="fa fa-google-plus"></i>
          </a>
          <a href="https://twitter.com/@krejcil">
            <i class="fa fa-twitter"></i>
          </a>
          <a href="https://www.linkedin.com/profile/view?id=45241872">
            <i class="fa fa-linkedin"></i>
          </a>
        </div>
        <p>&copy; Lukáš Krejčí 2014</p>
      </footer>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js" type="text/javascript"></script>
    <script src="http://lukas.krejci.pw/javascripts/bootstrap/collapse.js" type="text/javascript"></script>
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount','UA-56804098-1']);
    _gaq.push(['_trackPageview']);
    (function() {
     var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
     ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
     var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
  </body>
</html>
